redisNil	redis.html#redisNil	redis : redisNil	
Redis	redis.html#Redis	redis : Redis	
AsyncRedis	redis.html#AsyncRedis	redis : AsyncRedis	
RedisStatus	redis.html#RedisStatus	redis : RedisStatus	
RedisInteger	redis.html#RedisInteger	redis : RedisInteger	
RedisString	redis.html#RedisString	redis : RedisString	
RedisList	redis.html#RedisList	redis : RedisList	
ReplyError	redis.html#ReplyError	redis : ReplyError	
RedisError	redis.html#RedisError	redis : RedisError	
RedisCursor	redis.html#RedisCursor	redis : RedisCursor	
newCursor	redis.html#newCursor,BiggestInt	redis : newCursor*(pos: BiggestInt = 0): RedisCursor	
`$`	redis.html#$,RedisCursor	redis : `$`*(cursor: RedisCursor): string	
open	redis.html#open,	redis : open*(host = &quot;localhost&quot;; port = 6379.Port): Redis	
openAsync	redis.html#openAsync,	redis : openAsync*(host = &quot;localhost&quot;; port = 6379.Port): Future[AsyncRedis]	
flushPipeline	redis.html#flushPipeline,	redis : flushPipeline*(r: Redis | AsyncRedis; wasMulti = false): Future[RedisList]	
startPipelining	redis.html#startPipelining,	redis : startPipelining*(r: Redis | AsyncRedis)	
del	redis.html#del,,seq[string]	redis : del*(r: Redis | AsyncRedis; keys: seq[string]): Future[RedisInteger]	
exists	redis.html#exists,,string	redis : exists*(r: Redis | AsyncRedis; key: string): Future[bool]	
expire	redis.html#expire,,string,int	redis : expire*(r: Redis | AsyncRedis; key: string; seconds: int): Future[bool]	
expireAt	redis.html#expireAt,,string,int	redis : expireAt*(r: Redis | AsyncRedis; key: string; timestamp: int): Future[bool]	
keys	redis.html#keys,,string	redis : keys*(r: Redis | AsyncRedis; pattern: string): Future[RedisList]	
scan	redis.html#scan,,RedisCursor	redis : scan*(r: Redis | AsyncRedis; cursor: RedisCursor): Future[RedisList]	
scan	redis.html#scan,,RedisCursor,string	redis : scan*(r: Redis | AsyncRedis; cursor: RedisCursor; pattern: string): Future[RedisList]	
scan	redis.html#scan,,RedisCursor,string,int	redis : scan*(r: Redis | AsyncRedis; cursor: RedisCursor; pattern: string; count: int): Future[\n    RedisList]	
move	redis.html#move,,string,int	redis : move*(r: Redis | AsyncRedis; key: string; db: int): Future[bool]	
persist	redis.html#persist,,string	redis : persist*(r: Redis | AsyncRedis; key: string): Future[bool]	
randomKey	redis.html#randomKey,	redis : randomKey*(r: Redis | AsyncRedis): Future[RedisString]	
rename	redis.html#rename,,string,string	redis : rename*(r: Redis | AsyncRedis; key, newkey: string): Future[RedisStatus]	
renameNX	redis.html#renameNX,,string,string	redis : renameNX*(r: Redis | AsyncRedis; key, newkey: string): Future[bool]	
ttl	redis.html#ttl,,string	redis : ttl*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
keyType	redis.html#keyType,Redis,string	redis : keyType*(r: Redis; key: string): RedisStatus	
append	redis.html#append,,string,string	redis : append*(r: Redis | AsyncRedis; key, value: string): Future[RedisInteger]	
decr	redis.html#decr,,string	redis : decr*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
decrBy	redis.html#decrBy,,string,int	redis : decrBy*(r: Redis | AsyncRedis; key: string; decrement: int): Future[RedisInteger]	
mget	redis.html#mget,,seq[string]	redis : mget*(r: Redis | AsyncRedis; keys: seq[string]): Future[RedisList]	
get	redis.html#get,,string	redis : get*(r: Redis | AsyncRedis; key: string): Future[RedisString]	
getBit	redis.html#getBit,,string,int	redis : getBit*(r: Redis | AsyncRedis; key: string; offset: int): Future[RedisInteger]	
bitCount	redis.html#bitCount,,string,seq[string]	redis : bitCount*(r: Redis | AsyncRedis; key: string; limits: seq[string]): Future[RedisInteger]	
bitPos	redis.html#bitPos,,string,int,seq[string]	redis : bitPos*(r: Redis | AsyncRedis; key: string; bit: int; limits: seq[string]): Future[\n    RedisInteger]	
getRange	redis.html#getRange,,string,int,int	redis : getRange*(r: Redis | AsyncRedis; key: string; start, stop: int): Future[RedisString]	
getSet	redis.html#getSet,,string,string	redis : getSet*(r: Redis | AsyncRedis; key: string; value: string): Future[RedisString]	
incr	redis.html#incr,,string	redis : incr*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
incrBy	redis.html#incrBy,,string,int	redis : incrBy*(r: Redis | AsyncRedis; key: string; increment: int): Future[RedisInteger]	
msetk	redis.html#msetk,,seq[tuple[string,string]]	redis : msetk*(r: Redis | AsyncRedis; keyValues: seq[tuple[key, value: string]]): Future[void]	
setk	redis.html#setk,,string,string	redis : setk*(r: Redis | AsyncRedis; key, value: string): Future[void]	
setNX	redis.html#setNX,,string,string	redis : setNX*(r: Redis | AsyncRedis; key, value: string): Future[bool]	
setBit	redis.html#setBit,,string,int,string	redis : setBit*(r: Redis | AsyncRedis; key: string; offset: int; value: string): Future[\n    RedisInteger]	
setEx	redis.html#setEx,,string,int,string	redis : setEx*(r: Redis | AsyncRedis; key: string; seconds: int; value: string): Future[\n    RedisStatus]	
setRange	redis.html#setRange,,string,int,string	redis : setRange*(r: Redis | AsyncRedis; key: string; offset: int; value: string): Future[\n    RedisInteger]	
strlen	redis.html#strlen,,string	redis : strlen*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
hDel	redis.html#hDel,,string,string	redis : hDel*(r: Redis | AsyncRedis; key, field: string): Future[bool]	
hExists	redis.html#hExists,,string,string	redis : hExists*(r: Redis | AsyncRedis; key, field: string): Future[bool]	
hGet	redis.html#hGet,,string,string	redis : hGet*(r: Redis | AsyncRedis; key, field: string): Future[RedisString]	
hGetAll	redis.html#hGetAll,,string	redis : hGetAll*(r: Redis | AsyncRedis; key: string): Future[RedisList]	
hIncrBy	redis.html#hIncrBy,,string,string,int	redis : hIncrBy*(r: Redis | AsyncRedis; key, field: string; incr: int): Future[RedisInteger]	
hKeys	redis.html#hKeys,,string	redis : hKeys*(r: Redis | AsyncRedis; key: string): Future[RedisList]	
hLen	redis.html#hLen,,string	redis : hLen*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
hMGet	redis.html#hMGet,,string,seq[string]	redis : hMGet*(r: Redis | AsyncRedis; key: string; fields: seq[string]): Future[RedisList]	
hMSet	redis.html#hMSet,,string,seq[tuple[string,string]]	redis : hMSet*(r: Redis | AsyncRedis; key: string;\n       fieldValues: seq[tuple[field, value: string]]): Future[void]	
hSet	redis.html#hSet,,string,string,string	redis : hSet*(r: Redis | AsyncRedis; key, field, value: string): Future[RedisInteger]	
hSetNX	redis.html#hSetNX,,string,string,string	redis : hSetNX*(r: Redis | AsyncRedis; key, field, value: string): Future[RedisInteger]	
hVals	redis.html#hVals,,string	redis : hVals*(r: Redis | AsyncRedis; key: string): Future[RedisList]	
bLPop	redis.html#bLPop,,seq[string],int	redis : bLPop*(r: Redis | AsyncRedis; keys: seq[string]; timeout: int): Future[RedisList]	
bRPop	redis.html#bRPop,,seq[string],int	redis : bRPop*(r: Redis | AsyncRedis; keys: seq[string]; timeout: int): Future[RedisList]	
bRPopLPush	redis.html#bRPopLPush,,string,string,int	redis : bRPopLPush*(r: Redis | AsyncRedis; source, destination: string; timeout: int): Future[\n    RedisString]	
lIndex	redis.html#lIndex,,string,int	redis : lIndex*(r: Redis | AsyncRedis; key: string; index: int): Future[RedisString]	
lInsert	redis.html#lInsert,,string,bool,string,string	redis : lInsert*(r: Redis | AsyncRedis; key: string; before: bool; pivot, value: string): Future[\n    RedisInteger]	
lLen	redis.html#lLen,,string	redis : lLen*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
lPop	redis.html#lPop,,string	redis : lPop*(r: Redis | AsyncRedis; key: string): Future[RedisString]	
lPush	redis.html#lPush,,string,string,bool	redis : lPush*(r: Redis | AsyncRedis; key, value: string; create: bool = true): Future[RedisInteger]	
lRange	redis.html#lRange,,string,int,int	redis : lRange*(r: Redis | AsyncRedis; key: string; start, stop: int): Future[RedisList]	
lRem	redis.html#lRem,,string,string,int	redis : lRem*(r: Redis | AsyncRedis; key: string; value: string; count: int = 0): Future[\n    RedisInteger]	
lSet	redis.html#lSet,,string,int,string	redis : lSet*(r: Redis | AsyncRedis; key: string; index: int; value: string): Future[void]	
lTrim	redis.html#lTrim,,string,int,int	redis : lTrim*(r: Redis | AsyncRedis; key: string; start, stop: int): Future[void]	
rPop	redis.html#rPop,,string	redis : rPop*(r: Redis | AsyncRedis; key: string): Future[RedisString]	
rPopLPush	redis.html#rPopLPush,,string,string	redis : rPopLPush*(r: Redis | AsyncRedis; source, destination: string): Future[RedisString]	
rPush	redis.html#rPush,,string,string,bool	redis : rPush*(r: Redis | AsyncRedis; key, value: string; create: bool = true): Future[RedisInteger]	
sadd	redis.html#sadd,,string,string	redis : sadd*(r: Redis | AsyncRedis; key: string; member: string): Future[RedisInteger]	
scard	redis.html#scard,,string	redis : scard*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
sdiff	redis.html#sdiff,,seq[string]	redis : sdiff*(r: Redis | AsyncRedis; keys: seq[string]): Future[RedisList]	
sdiffstore	redis.html#sdiffstore,,string,seq[string]	redis : sdiffstore*(r: Redis | AsyncRedis; destination: string; keys: seq[string]): Future[\n    RedisInteger]	
sinter	redis.html#sinter,,seq[string]	redis : sinter*(r: Redis | AsyncRedis; keys: seq[string]): Future[RedisList]	
sinterstore	redis.html#sinterstore,,string,seq[string]	redis : sinterstore*(r: Redis | AsyncRedis; destination: string; keys: seq[string]): Future[\n    RedisInteger]	
sismember	redis.html#sismember,,string,string	redis : sismember*(r: Redis | AsyncRedis; key: string; member: string): Future[RedisInteger]	
smembers	redis.html#smembers,,string	redis : smembers*(r: Redis | AsyncRedis; key: string): Future[RedisList]	
smove	redis.html#smove,,string,string,string	redis : smove*(r: Redis | AsyncRedis; source: string; destination: string; member: string): Future[\n    RedisInteger]	
spop	redis.html#spop,,string	redis : spop*(r: Redis | AsyncRedis; key: string): Future[RedisString]	
srandmember	redis.html#srandmember,,string	redis : srandmember*(r: Redis | AsyncRedis; key: string): Future[RedisString]	
srem	redis.html#srem,,string,string	redis : srem*(r: Redis | AsyncRedis; key: string; member: string): Future[RedisInteger]	
sunion	redis.html#sunion,,seq[string]	redis : sunion*(r: Redis | AsyncRedis; keys: seq[string]): Future[RedisList]	
sunionstore	redis.html#sunionstore,,string,seq[string]	redis : sunionstore*(r: Redis | AsyncRedis; destination: string; key: seq[string]): Future[\n    RedisInteger]	
zadd	redis.html#zadd,,string,int,string	redis : zadd*(r: Redis | AsyncRedis; key: string; score: int; member: string): Future[RedisInteger]	
zcard	redis.html#zcard,,string	redis : zcard*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
zcount	redis.html#zcount,,string,string,string	redis : zcount*(r: Redis | AsyncRedis; key: string; min: string; max: string): Future[RedisInteger]	
zincrby	redis.html#zincrby,,string,string,string	redis : zincrby*(r: Redis | AsyncRedis; key: string; increment: string; member: string): Future[\n    RedisString]	
zinterstore	redis.html#zinterstore,,string,string,seq[string],seq[string],string	redis : zinterstore*(r: Redis | AsyncRedis; destination: string; numkeys: string;\n             keys: seq[string]; weights: seq[string] = @ []; aggregate: string = &quot;&quot;): Future[\n    RedisInteger]	
zrange	redis.html#zrange,,string,string,string,bool	redis : zrange*(r: Redis | AsyncRedis; key: string; start: string; stop: string;\n        withScores: bool = false): Future[RedisList]	
zrangebyscore	redis.html#zrangebyscore,,string,string,string,bool,bool,int,int	redis : zrangebyscore*(r: Redis | AsyncRedis; key: string; min: string; max: string;\n               withScores: bool = false; limit: bool = false; limitOffset: int = 0;\n               limitCount: int = 0): Future[RedisList]	
zrangebylex	redis.html#zrangebylex,,string,string,string,bool,int,int	redis : zrangebylex*(r: Redis | AsyncRedis; key: string; start: string; stop: string;\n             limit: bool = false; limitOffset: int = 0; limitCount: int = 0): Future[\n    RedisList]	
zrank	redis.html#zrank,,string,string	redis : zrank*(r: Redis | AsyncRedis; key: string; member: string): Future[RedisString]	
zrem	redis.html#zrem,,string,string	redis : zrem*(r: Redis | AsyncRedis; key: string; member: string): Future[RedisInteger]	
zremrangebyrank	redis.html#zremrangebyrank,,string,string,string	redis : zremrangebyrank*(r: Redis | AsyncRedis; key: string; start: string; stop: string): Future[\n    RedisInteger]	
zremrangebyscore	redis.html#zremrangebyscore,,string,string,string	redis : zremrangebyscore*(r: Redis | AsyncRedis; key: string; min: string; max: string): Future[\n    RedisInteger]	
zrevrange	redis.html#zrevrange,,string,string,string,bool	redis : zrevrange*(r: Redis | AsyncRedis; key: string; start: string; stop: string;\n           withScores: bool = false): Future[RedisList]	
zrevrangebyscore	redis.html#zrevrangebyscore,,string,string,string,bool,bool,int,int	redis : zrevrangebyscore*(r: Redis | AsyncRedis; key: string; min: string; max: string;\n                  withScores: bool = false; limit: bool = false; limitOffset: int = 0;\n                  limitCount: int = 0): Future[RedisList]	
zrevrank	redis.html#zrevrank,,string,string	redis : zrevrank*(r: Redis | AsyncRedis; key: string; member: string): Future[RedisString]	
zscore	redis.html#zscore,,string,string	redis : zscore*(r: Redis | AsyncRedis; key: string; member: string): Future[RedisString]	
zunionstore	redis.html#zunionstore,,string,string,seq[string],seq[string],string	redis : zunionstore*(r: Redis | AsyncRedis; destination: string; numkeys: string;\n             keys: seq[string]; weights: seq[string] = @ []; aggregate: string = &quot;&quot;): Future[\n    RedisInteger]	
pfadd	redis.html#pfadd,,string,seq[string]	redis : pfadd*(r: Redis | AsyncRedis; key: string; elements: seq[string]): Future[RedisInteger]	
pfcount	redis.html#pfcount,,string	redis : pfcount*(r: Redis | AsyncRedis; key: string): Future[RedisInteger]	
pfmerge	redis.html#pfmerge,,string,seq[string]	redis : pfmerge*(r: Redis | AsyncRedis; destination: string; sources: seq[string]): Future[void]	
discardMulti	redis.html#discardMulti,	redis : discardMulti*(r: Redis | AsyncRedis): Future[void]	
exec	redis.html#exec,	redis : exec*(r: Redis | AsyncRedis): Future[RedisList]	
multi	redis.html#multi,	redis : multi*(r: Redis | AsyncRedis): Future[void]	
unwatch	redis.html#unwatch,	redis : unwatch*(r: Redis | AsyncRedis): Future[void]	
watch	redis.html#watch,,seq[string]	redis : watch*(r: Redis | AsyncRedis; key: seq[string]): Future[void]	
auth	redis.html#auth,,string	redis : auth*(r: Redis | AsyncRedis; password: string): Future[void]	
echoServ	redis.html#echoServ,,string	redis : echoServ*(r: Redis | AsyncRedis; message: string): Future[RedisString]	
ping	redis.html#ping,	redis : ping*(r: Redis | AsyncRedis): Future[RedisStatus]	
quit	redis.html#quit,	redis : quit*(r: Redis | AsyncRedis): Future[void]	
select	redis.html#select,,int	redis : select*(r: Redis | AsyncRedis; index: int): Future[RedisStatus]	
bgrewriteaof	redis.html#bgrewriteaof,	redis : bgrewriteaof*(r: Redis | AsyncRedis): Future[void]	
bgsave	redis.html#bgsave,	redis : bgsave*(r: Redis | AsyncRedis): Future[void]	
configGet	redis.html#configGet,,string	redis : configGet*(r: Redis | AsyncRedis; parameter: string): Future[RedisList]	
configSet	redis.html#configSet,,string,string	redis : configSet*(r: Redis | AsyncRedis; parameter: string; value: string): Future[void]	
configResetStat	redis.html#configResetStat,	redis : configResetStat*(r: Redis | AsyncRedis): Future[void]	
dbsize	redis.html#dbsize,	redis : dbsize*(r: Redis | AsyncRedis): Future[RedisInteger]	
debugObject	redis.html#debugObject,,string	redis : debugObject*(r: Redis | AsyncRedis; key: string): Future[RedisStatus]	
debugSegfault	redis.html#debugSegfault,	redis : debugSegfault*(r: Redis | AsyncRedis): Future[void]	
flushall	redis.html#flushall,	redis : flushall*(r: Redis | AsyncRedis): Future[RedisStatus]	
flushdb	redis.html#flushdb,	redis : flushdb*(r: Redis | AsyncRedis): Future[RedisStatus]	
info	redis.html#info,	redis : info*(r: Redis | AsyncRedis): Future[RedisString]	
lastsave	redis.html#lastsave,	redis : lastsave*(r: Redis | AsyncRedis): Future[RedisInteger]	
save	redis.html#save,	redis : save*(r: Redis | AsyncRedis): Future[void]	
shutdown	redis.html#shutdown,	redis : shutdown*(r: Redis | AsyncRedis): Future[void]	
slaveof	redis.html#slaveof,,string,string	redis : slaveof*(r: Redis | AsyncRedis; host: string; port: string): Future[void]	
hPairs	redis.html#hPairs.i,Redis,string	redis : hPairs*(r: Redis; key: string): tuple[key, value: string]	
hPairs	redis.html#hPairs,AsyncRedis,string	redis : hPairs*(r: AsyncRedis; key: string): Future[seq[tuple[key, value: string]]]	
